// Generated by CoffeeScript 1.8.0
var CLOSE_MESSAGE, ClosedError, TIMEOUT_MESSAGE, create_cb, create_pool, debug, genericPool, id, retry_fn, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require("lodash");

genericPool = require("generic-pool");

debug = require("debug")("thrift-pool");

TIMEOUT_MESSAGE = "Thrift-pool: Connection timeout";

CLOSE_MESSAGE = "Thrift-pool: Connection closed";

ClosedError = (function(_super) {
  __extends(ClosedError, _super);

  function ClosedError() {
    return ClosedError.__super__.constructor.apply(this, arguments);
  }

  ClosedError.prototype.closed = true;

  return ClosedError;

})(Error);

id = 0;

create_cb = function(thrift, pool_options, thrift_options, cb) {
  var connection;
  cb = _.once(cb);
  connection = thrift.createConnection(pool_options.host, pool_options.port, thrift_options);
  connection.__ended = false;
  connection.__id = id += 1;
  connection.on("connect", function() {
    debug("in connect callback");
    connection.connection.setKeepAlive(true);
    return cb(null, connection);
  });
  connection.on("error", function(err) {
    debug("in error callback");
    connection.__ended = true;
    debug({
      err: err,
      connection_id: connection.__id
    });
    return cb(err);
  });
  connection.on("close", function() {
    debug("in close callback");
    connection.__ended = true;
    return cb(new ClosedError(CLOSE_MESSAGE));
  });
  if (thrift_options.timeout != null) {
    debug("adding timeout listener");
    return connection.on("timeout", function() {
      debug("in timeout callback");
      connection.__ended = true;
      return cb(new Error(TIMEOUT_MESSAGE));
    });
  }
};

create_pool = function(thrift, pool_options, thrift_options) {
  var pool;
  if (pool_options == null) {
    pool_options = {};
  }
  if (thrift_options == null) {
    thrift_options = {};
  }
  return pool = genericPool.Pool({
    name: "thrift",
    create: function(cb) {
      return create_cb(thrift, pool_options, thrift_options, cb);
    },
    destroy: function(connection) {
      debug("in destroy");
      return connection.end();
    },
    validate: function(connection) {
      debug("in validate");
      return !connection.__ended;
    },
    max: pool_options.max_connections,
    min: pool_options.min_connections,
    idleTimeoutMillis: pool_options.idle_timeout
  });
};

retry_fn = function(num_retries, is_retryable, fn, cb) {
  return fn(function(err, result) {
    if (err) {
      debug({
        err: err
      });
      debug({
        num_retries: num_retries,
        is_retryable: is_retryable(err)
      });
    }
    if (!err || !is_retryable(err) || num_retries <= 0) {
      debug('calling callback');
      return cb(err, result);
    } else {
      debug('retrying');
      return retry_fn(num_retries - 1, is_retryable, fn, cb);
    }
  });
};

module.exports = function(thrift, service, pool_options, thrift_options) {
  var add_listeners, key, pool, remove_listeners, should_retry, wrap_thrift_attempt, wrap_thrift_fn, _i, _len, _ref;
  if (pool_options == null) {
    pool_options = {};
  }
  if (thrift_options == null) {
    thrift_options = {};
  }
  _ref = ["host", "port"];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    key = _ref[_i];
    if (!pool_options[key]) {
      throw new Error("Thrift-pool: You must specify " + key);
    }
  }
  pool_options = _.defaults(pool_options, {
    max_connections: 1,
    min_connections: 0,
    idle_timeout: 10000,
    retries: 2
  });
  pool = create_pool(thrift, pool_options, thrift_options);
  add_listeners = function(connection, cb_error, cb_timeout, cb_close) {
    connection.on("error", cb_error);
    connection.on("close", cb_close);
    if (thrift_options.timeout != null) {
      return connection.on("timeout", cb_timeout);
    }
  };
  remove_listeners = function(connection, cb_error, cb_timeout, cb_close) {
    connection.removeListener("error", cb_error);
    connection.removeListener("close", cb_close);
    if (thrift_options.timeout != null) {
      return connection.removeListener("timeout", cb_timeout);
    }
  };
  wrap_thrift_attempt = function(fn) {
    return function() {
      var args, cb, _j;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _j = arguments.length - 1) : (_j = 0, []), cb = arguments[_j++];
      return pool.acquire(function(err, connection) {
        var cb_close, cb_error, cb_timeout, client;
        debug("Connection acquired");
        if (err != null) {
          debug({
            err: err,
            connection_id: connection != null ? connection.__id : void 0
          });
        }
        if (err != null) {
          return cb(err);
        }
        cb = _.once(cb);
        cb_error = function(err) {
          debug("in error callback, post-acquire listener");
          debug({
            err: err,
            connection_id: connection.__id
          });
          return cb(err);
        };
        cb_timeout = function() {
          debug("in timeout callback, post-acquire listener");
          debug({
            err: err,
            connection_id: connection.__id
          });
          return cb(new Error(TIMEOUT_MESSAGE));
        };
        cb_close = function() {
          debug("in close callback, post-acquire listener");
          debug({
            err: err,
            connection_id: connection.__id
          });
          return cb(new ClosedError(CLOSE_MESSAGE));
        };
        add_listeners(connection, cb_error, cb_timeout, cb_close);
        client = thrift.createClient(service, connection);
        debug("Client created");
        debug({
          client: client
        });
        return client[fn].apply(client, __slice.call(args).concat([function() {
          var err, results;
          err = arguments[0], results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          debug("In client callback");
          remove_listeners(connection, cb_error, cb_timeout, cb_close);
          pool.release(connection);
          return cb.apply(null, [err].concat(__slice.call(results)));
        }]));
      });
    };
  };
  should_retry = function(err) {
    return err.closed || err.code === 'ECONNRESET' || err.errno === 'ECONNRESET';
  };
  wrap_thrift_fn = function(fn_name) {
    var wrapped;
    wrapped = wrap_thrift_attempt(fn_name);
    return function() {
      var args, call, callback, _j;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _j = arguments.length - 1) : (_j = 0, []), callback = arguments[_j++];
      call = function(cb) {
        return wrapped.apply(null, __slice.call(args).concat([cb]));
      };
      return retry_fn(pool_options.retries, should_retry, call, callback);
    };
  };
  return _(service.Client.prototype).functions().map(function(name) {
    return [name, wrap_thrift_fn(name)];
  }).zipObject().value();
};

_.extend(module.exports, {
  _private: {
    create_pool: create_pool,
    retry_fn: retry_fn,
    TIMEOUT_MESSAGE: TIMEOUT_MESSAGE,
    CLOSE_MESSAGE: CLOSE_MESSAGE
  }
});

//# sourceMappingURL=index.js.map
